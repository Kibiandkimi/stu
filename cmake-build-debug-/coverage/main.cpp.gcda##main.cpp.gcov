        -:    0:Source:F:/c++/VS/stu/main.cpp
        -:    0:Graph:F:\c++\VS\stu\cmake-build-debug-\CMakeFiles\stu.dir\main.cpp.gcno
        -:    0:Data:F:\c++\VS\stu\cmake-build-debug-\CMakeFiles\stu.dir\main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by kibi on 2022/8/4.
        -:    3://
        -:    4:#include <bits/stdc++.h>
        -:    5:using namespace std;
        -:    6:int n, cnt = 1;
        -:    7:long long ans;
        -:    8:char c[10];
        -:    9:struct node {
        -:   10:    int v = 0;
        -:   11:    int son[52] = {0};
        -:   12:} tr[500005];
        -:   13:int g[100005];
        -:   14:
function _Z1hc called 26 returned 100% blocks executed 100%
       26:   15:int h(char s) {
       26:   16:    if ('a' <= s && s <= 'z') {
       26:   16-block  0
branch  0 taken 20 (fallthrough)
branch  1 taken 6
       20:   16-block  1
branch  2 taken 20 (fallthrough)
branch  3 taken 0
       20:   17:        return s - 'a';
       20:   17-block  0
        -:   18:    } else {
        6:   19:        return s - 'A' + 26;
        6:   19-block  0
        -:   20:    }
        -:   21:}
        -:   22:
function _Z6inserti called 3 returned 100% blocks executed 100%
        3:   23:void insert(int id) {
        3:   24:    int u = 1;
       16:   25:    for (int i = 1; c[i] != 0; i++) {
        3:   25-block  0
       16:   25-block  1
branch  0 taken 13 (fallthrough)
branch  1 taken 3
        -:   26:        //        if (!tr[u].son[h(c[i])]){
        -:   27:        //            tr[u].son[h(c[i])] = ++cnt;
        -:   28:        //        }
        -:   29:        //        u = tr[u].son[h(c[i])];
       13:   30:        int &t = tr[u].son[h(c[i])];
       13:   30-block  0
call    0 returned 13
       13:   31:        u = t = t?t:++cnt;
branch  0 taken 1 (fallthrough)
branch  1 taken 12
        1:   31-block  0
       12:   31-block  1
       13:   31-block  2
        -:   32:    }
        3:   33:    tr[u].v = id;
        3:   34:}
        -:   35:
function _Z5queryv called 3 returned 100% blocks executed 100%
        3:   36:int query(){
        3:   37:    int u = 1;
       16:   38:    for(int i = 1; c[i] != 0; i++){
        3:   38-block  0
       16:   38-block  1
branch  0 taken 13 (fallthrough)
branch  1 taken 3
       13:   39:        u = tr[u].son[h(c[i])];
       13:   39-block  0
call    0 returned 13
        -:   40:    }
        3:   41:    return tr[u].v;
        3:   41-block  0
        -:   42:}
        -:   43:
function _Z2gbii called 5 returned 100% blocks executed 100%
        5:   44:void gb(int l, int r){
        5:   45:    if(l == r){
        5:   45-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:   46:        return ;
        3:   46-block  0
        -:   47:    }
        2:   48:    int mid = (l+r)/2;
        2:   49:    gb(l, mid);
        2:   49-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   50:    gb(mid+1, r);
        2:   50-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   51:    int i = l, j = mid+1, t[100005], cnt = 1;
        2:   51-block  0
        5:   52:    while(i <= mid && j <= r){
        5:   52-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:   52-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 1
        3:   52-block  2
        3:   53:        if(g[i] < g[j]){
        3:   53-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:   54:            t[cnt++] = g[i];
        2:   55:            i++;
        2:   55-block  0
        -:   56:        }else{
        1:   57:            ans += mid-i+1;
        1:   58:            t[cnt++] = g[j];
        1:   59:            j++;
        1:   59-block  0
        -:   60:        }
        -:   61:    }
        3:   62:    while(j <= r){
        3:   62-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   63:        t[cnt++] = g[j];
        1:   64:        j++;
        1:   64-block  0
        -:   65:    }
        3:   66:    while(i <= mid){
        3:   66-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   67:        t[cnt++] = g[i];
        1:   68:        i++;
        1:   68-block  0
        -:   69:    }
        7:   70:    for(int k = l; k <= r; k++){
        2:   70-block  0
        7:   70-block  1
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5:   71:        g[k] = t[k-l+1];
        5:   71-block  0
        -:   72:    }
        -:   73:}
        -:   74:
function main called 1 returned 100% blocks executed 100%
        1:   75:int main() {
        1:   76:    scanf("%d", &n);
        1:   76-block  0
call    0 returned 1
        1:   77:    memset(tr, 0, sizeof tr);
        4:   78:    for (int i = 1; i <= n; i++) {
        4:   78-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:   79:        scanf("%s", c + 1);
        3:   79-block  0
call    0 returned 3
        3:   80:        insert(i);
call    0 returned 3
        -:   81:    }
        4:   82:    for(int i = 1; i <= n; i++){
        1:   82-block  0
        4:   82-block  1
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:   83:        scanf("%s", c+1);
        3:   83-block  0
call    0 returned 3
        3:   84:        g[i] = query();
call    0 returned 3
        -:   85:    }
        1:   86:    gb(1, n);
        1:   86-block  0
call    0 returned 1
        1:   87:    printf("%lld", ans);
call    0 returned 1
        1:   88:}
